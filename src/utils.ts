import { loadNostrUser, type NostrUser } from '@nostr/gadgets/metadata';
import { decode } from '@nostr/tools/nip19';
import showdown from 'showdown';
import { type NostrEvent } from '@nostr/tools/core';
import * as nip27 from '@nostr/tools/nip27';
import * as nip19 from '@nostr/tools/nip19';

export function isRootNote(event: NostrEvent) {
  // Loop through the tags and check the condition
  for (let tag of event.tags) {
    if (tag[0] === 'e' && (tag[3] === 'root' || tag[3] === 'reply')) {
      return false;
    }
  }
  return true;
}

export type EventData = {
  id: string;
  kind: number;
  created_at: number;
  title: string;
  autogeneratedTitle: boolean;
  summary: string | undefined;
  image: string | undefined;
  images: string[] | [];
  content: string;
  renderedContent: string;
};

const dateFormatter = new Intl.DateTimeFormat('en-US', {
  day: '2-digit',
  month: 'long',
  year: 'numeric'
});

export function getEventData(event: NostrEvent): EventData {
  let extractedTitle: string | undefined;
  let extractedSummary: string | undefined;
  const extractedImages: string[] = [];
  let extractedImage: string | undefined;
  let autogeneratedTitle = false;

  if (event.kind === 30023) {
    extractedTitle = event.tags.find(([k]) => k === 'title')?.[1];
    if (!extractedTitle) {
      extractedTitle = 'Article of ' + dateFormatter.format(new Date(event.created_at * 1000));
      autogeneratedTitle = true;
    }

    extractedSummary = event.tags.find(([k]) => k === 'summary')?.[1] || undefined;
    extractedImage = event.tags.find(([k]) => k === 'image')?.[1] || undefined;
  } else if (event.kind == 20) {
    extractedTitle = event.tags.find(([k]) => k === 'title')?.[1];
    if (!extractedTitle) {
      extractedTitle = 'Photo of ' + dateFormatter.format(new Date(event.created_at * 1000));
      autogeneratedTitle = true;
    }
    extractedSummary = event.content;
    event.tags.forEach((tag) => {
      if (tag[0] === 'imeta') {
        const url = tag[1].split(' ')[1];
        extractedImages.push(url);
      }
    });
    extractedImage = extractedImages[0];
  } else {
    extractedTitle = event.tags.find(([k]) => k === 'subject')?.[1];
    if (!extractedTitle) {
      extractedTitle = 'Note of ' + dateFormatter.format(new Date(event.created_at * 1000));
      autogeneratedTitle = true;
    }
    extractedSummary = shortenUrlsAndIdentifiersAndShrinkTo(event.content, 504);
    if (extractedSummary.length > 503) {
      extractedSummary = extractedSummary.substring(0, 500);
      while (extractedSummary.endsWith('.')) {
        extractedSummary = extractedSummary?.substring(0, extractedSummary.length - 1);
      }
      if (extractedSummary.endsWith(' ')) {
        extractedSummary = extractedSummary.trimEnd() + ' (...)';
      } else {
        extractedSummary += '...';
      }
    }
  }

  return {
    id: event.id,
    kind: event.kind,
    created_at: event.created_at,
    title: extractedTitle,
    autogeneratedTitle: autogeneratedTitle,
    image: extractedImage,
    images: extractedImages,
    summary: extractedSummary,
    content: event.content
  };
}

export async function resolveNip05(address: string): Promise<string | null> {
  try {
    const match = address.match(/^([a-zA-Z0-9-_.]+)@([a-zA-Z0-9-.]+)$/);
    if (!match) {
      return null;
    }

    const [_, name, domain] = match;
    const url = `https://${domain}/.well-known/nostr.json?name=${name}`;

    const response = await fetch(url);
    if (!response.ok) {
      console.error(`Failed to fetch NIP-05 data: ${response.status}`);
      return null;
    }

    const data = await response.json();
    if (data && data.names && data.names[name]) {
      return data.names[name]; // Return the hex pubkey
    }

    return null;
  } catch (error) {
    console.error('Error resolving NIP-05 address:', error);
    return null;
  }
}

export async function getProfile(code: string): Promise<NostrUser | null> {
  let pubkey: string;
  let relays: string[] = [];

  // Check if it's a NIP-05 identifier
  if (code.includes('@')) {
    const resolvedPubkey = await resolveNip05(code);
    if (resolvedPubkey) {
      pubkey = resolvedPubkey;
    } else {
      console.error('Failed to resolve NIP-05 address');
      return null;
    }
  } else {
    try {
      let result = decode(code);
      if (result.type === 'npub') {
        pubkey = result.data;
      } else if (result.type === 'nprofile') {
        pubkey = result.data.pubkey;
        relays = result.data.relays || [];
      } else {
        console.error('author should be an npub');
        return null;
      }
    } catch (err) {
      if (code.length === 64) {
        pubkey = code;
      } else {
        console.error('Failed to decode npub:', err);
        return null;
      }
    }
  }

  return loadNostrUser({ pubkey, relays });
}

export async function processUsersEntities(content: string) {
  const regexPrefixedEntities = /nostr:(npub1\w+|nprofile1\w+)/g;
  const matches = content.match(regexPrefixedEntities) || [];

  const replacementPromises = matches.map(async (match) => {
    try {
      const profile = await getProfile(match.slice(6)); // Remove "nostr:" prefix

      if (profile) {
        return {
          match,
          replacement: `<a href='https://njump.me/${match}'>${profile.shortName}</a>`
        };
      } else {
        return { match, replacement: match }; // Fallback to original match
      }
    } catch (error) {
      console.error('Failed to fetch profile:', error);
      return { match, replacement: match }; // Fallback to original match
    }
  });

  const replacements = await Promise.all(replacementPromises);
  let processedContent = content;
  replacements.forEach(({ match, replacement }) => {
    processedContent = processedContent.replace(match, replacement);
  });

  return processedContent;
}

export function processEventsEntities(content: string) {
  // Prefix plain "nevent1|note1|npub1|nprofile|<alphanumeric string>" with nostr: for further processing
  // Include also entities without prefix inside a markdown link, e.g. [text](nevent1xxxxx)
  const regexEntities = /(^|\s|\n|\()(nevent1\w+|note1\w+|npub1\w+|nprofile1\w+)(?=\s|\n|\)|$)/gm;
  content = content.replace(regexEntities, (_, p1, group1) => {
    // const shortenedString = group1.slice(0, 24);
    return `${p1}nostr:${group1}`;
  });

  // Transform plain nostr:(nevent1|note1|npub1|nprofile)<alphanumeric string> in HTML links
  const regexPrefixedEntities =
    /(^|\s|\n)nostr:(nevent1\w+|note1\w+|npub1\w+|nprofile1\w+)(?=\s|\n|$)/gm;
  content = content.replace(regexPrefixedEntities, (_, p1, group1) => {
    const shortenedString = group1.slice(0, 24);
    return `${p1}<a href='https://njump.me/${group1}'>${shortenedString}</a>`;
  });

  return content;
}

export function cleanMarkdownLinks(content: string) {
  // Regular expression to match markdown links
  const regexMarkdownLinks = /\[([^\]]+)\]\(([^)]+)\)/g;

  // Replace markdown links with just the text
  const cleanedText = content.replace(regexMarkdownLinks, (_, p1) => p1);

  return cleanedText;
}

export function processPlainUrls(content: string) {
  // Regex to match plain URLs, excluding those:
  // 1. Within parentheses
  // 2. Already inside HTML tags
  // 3. Image or video URLs
  const plainUrlRegex =
    /(?<![(])(?![^<]*>)(https?:\/\/\S+(?:(?!\.(?:png|jpg|jpeg|gif|bmp|mp4|webm|ogg|mov))\S*))/gi;

  // Replace plain URLs with HTML anchor tags
  const htmlText = content.replace(plainUrlRegex, (match) => {
    // Truncate long URLs for display
    const displayText = match.length > 75 ? `${match.slice(0, 72)}...` : match;

    return ` <a href="${match}" target="_blank" rel="noopener noreferrer">${displayText}</a> `;
  });

  return htmlText;
}

export function shortenUrlsAndIdentifiersAndShrinkTo(
  extractedSummary: string,
  limit: number
): string {
  let next = '';

  for (let block of nip27.parse(extractedSummary)) {
    switch (block.type) {
      case 'text':
        next += block.text;
        break;
      case 'url':
      case 'image':
      case 'video':
      case 'audio':
      case 'relay':
        next += shortenURL(block.url);
        break;
      case 'reference':
        let enc: string;
        if ('id' in block.pointer) {
          enc = nip19.neventEncode(block.pointer);
        } else if ('identifier' in block.pointer) {
          enc = nip19.naddrEncode(block.pointer);
        } else {
          enc = nip19.npubEncode(block.pointer.pubkey);
        }
        next += shorten(enc);
        break;
    }

    if (next.length > limit) {
      break;
    }
  }

  return next;
}

export function processImageUrls(content: string) {
  // Regex to match image URLs, excluding those between parentheses
  const imageUrlRegex = /(?<![(])(https?:\/\/\S+\.(?:png|jpg|jpeg|gif|bmp))(?![\)])/g;

  // Replace the image URL with HTML syntax
  const markdownText = content.replace(imageUrlRegex, (_, group) => {
    return ` <img src='${group}' /> `; // Markdown syntax for displaying an image
  });

  return markdownText;
}

export function processVideoUrls(content: string) {
  // Regular expression to match the video URL and markdown image-style syntax
  const videoUrlRegex =
    /(?:https?:\/\/\S+\.(?:mp4|webm|ogg|mov))|(?:\!\[.*?\]\((https?:\/\/\S+\.(?:mp4|webm|ogg|mov))\))/gi;

  // Replace the video URL with HTML <video> tag
  const htmlText = content.replace(videoUrlRegex, (match) => {
    // Extract the URL from either plain URL or markdown-style link
    const url =
      match.match(/https?:\/\/\S+\.(?:mp4|webm|ogg|mov)/)?.[0] ||
      match.match(/\((https?:\/\/\S+\.(?:mp4|webm|ogg|mov))\)/)?.[1];

    if (!url) return match; // Fallback if no URL is found

    return ` <video controls><source src="${url}" type="video/mp4"></video> `;
  });

  return htmlText;
}

export function processAudioUrls(content: string) {
  // Regular expression to match the audio URL
  const audioUrlRegex = /\s*(https?:\/\/\S+\.(?:mp3|wav|ogg|aac|flac|m4a|opus))(\s*|$)/gi;

  // Replace the audio URL with HTML <audio> tag
  const htmlText = content.replace(audioUrlRegex, (_, group) => {
    return ` <audio controls src="${group}"></audio> `;
  });

  return htmlText;
}

export function processSmartyPants(content: string) {
  const replacements = [
    { regex: /<<|»/g, replacement: '&laquo;' },
    { regex: />>|«/g, replacement: '&raquo;' },
    { regex: /\.\.\./g, replacement: '&hellip;' },
    { regex: /---/g, replacement: '&mdash;' },
    { regex: /--/g, replacement: '&mdash;' }
  ];

  // Split content by <pre> and <code> tags, preserve them, and process only text outside
  const parts: Array<{ text: string; isProtected: boolean }> = [];
  let index = 0;

  const protectedRegex = /(<pre[^>]*>[\s\S]*?<\/pre>|<code[^>]*>[\s\S]*?<\/code>)/gi;
  let match;

  while ((match = protectedRegex.exec(content)) !== null) {
    if (match.index > index) {
      parts.push({ text: content.slice(index, match.index), isProtected: false });
    }
    parts.push({ text: match[0], isProtected: true });
    index = match.index + match[0].length;
  }

  if (index < content.length) {
    parts.push({ text: content.slice(index), isProtected: false });
  }

  if (parts.length === 0) {
    parts.push({ text: content, isProtected: false });
  }

  return parts
    .map((part) => {
      if (part.isProtected) {
        return part.text;
      }
      let processedText = part.text;
      replacements.forEach(({ regex, replacement }) => {
        processedText = processedText.replace(regex, replacement);
      });
      return processedText;
    })
    .join('');
}

export async function processContent(event: EventData): Promise<EventData> {
  event.renderedContent = await processAll(event);
  return event;
}

export async function processAll(note: EventData | NostrEvent): Promise<string> {
  let noteContent = note.content;
  // Replace users entities with names
  noteContent = await processUsersEntities(noteContent);
  noteContent = processEventsEntities(noteContent);
  noteContent = processImageUrls(noteContent);
  noteContent = processVideoUrls(noteContent);
  noteContent = processAudioUrls(noteContent);

  // Render returns in kind:1
  if (note.kind == 1) {
    noteContent = noteContent.replace(/\n/g, '\n<br/>');
    noteContent = processPlainUrls(noteContent);
  }

  // Strip duplicate h1 title
  if ('title' in note) {
    noteContent = noteContent.replace('# ' + note.title, '');
  }

  // Render markdown
  if (note.kind === 30023) {
    let converter = new showdown.Converter({
      simplifiedAutoLink: true,
      tables: true,
      strikethrough: true
    });
    noteContent = converter.makeHtml(noteContent);
  }

  // Process smartypants after the markdown conversion, to manage pre/code blocks
  noteContent = processSmartyPants(noteContent);

  return noteContent;
}

export function formatDate(timestamp: number, includeTime = false) {
  const date = new Date(timestamp * 1000);

  // Set date options
  const dateOptions: Intl.DateTimeFormatOptions = {
    day: '2-digit',
    month: 'long',
    year: 'numeric'
  };
  const dateParts = new Intl.DateTimeFormat('en-US', dateOptions).formatToParts(date);

  let day, month, year;
  dateParts.forEach((part) => {
    if (part.type === 'day') day = part.value;
    if (part.type === 'month') month = part.value;
    if (part.type === 'year') year = part.value;
  });

  let formattedDate = `${day} ${month} ${year}`;

  // If includeTime is true, add the time in 24-hour format
  if (includeTime) {
    const timeOptions: Intl.DateTimeFormatOptions = {
      hour: '2-digit',
      minute: '2-digit',
      hourCycle: 'h23'
    };
    const timeFormatter = new Intl.DateTimeFormat('en-US', timeOptions);
    const timeString = timeFormatter.format(date);
    formattedDate += ` - ${timeString}`;
  }

  return formattedDate;
}

export async function downloadHtmlApp(): Promise<void> {
  try {
    console.log(window.location.href.split('#')[0]);
    const response = await fetch(window.location.href.split('?')[0].split('#')[0] + '?bundled=1', {
      method: 'GET',
      headers: {
        Accept: 'text/html'
      }
    });

    if (!response.ok) {
      throw new Error('Network response was not ok');
    }

    const originalHTML = await response.text();
    const blob = new Blob([originalHTML], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'index.html';
    link.click();
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error('Error downloading the original HTML:', error);
  }
}

function shorten(nip19code: string): string {
  let idx = nip19code.indexOf('1');
  return nip19code.substring(0, idx + 3) + '…' + nip19code.substring(nip19code.length - 5);
}

function shortenURL(url: string): string {
  if (url.length <= 30) return url;
  try {
    let u = new URL(url);
    if (url.length <= 40) {
      return `${u.host}${u.pathname}${u.search.length ? '?' : ''}${u.search}`;
    }
    if (url.length <= 50 && u.pathname.length < 20) {
      return `${u.host}${u.pathname}`;
    }
    let pathname = u.pathname;
    let parts = u.pathname.split('/');

    let lastPart = parts[parts.length - 1];
    if (lastPart.length > 10) {
      lastPart = `…${lastPart.substring(lastPart.length - 6)}`;
    }

    if (parts.length > 2) {
      pathname = `/…/${lastPart}`;
    } else {
      pathname = `/${lastPart}`;
    }
    return `${u.host}${pathname}`;
  } catch (_err) {
    return url;
  }
}
